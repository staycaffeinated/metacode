# The MetaCode Code Generator

This utility generates boilerplate code with simple
command line arguments. The utility currently supports:

* RESTful web services based on Spring

This project is a rewrite of the Mojo code generator.

## Features

A project generated by MetaCode has these features:

* Uses Spring framework
* Uses Gradle build files
* Generates unit and integration tests that provide 100% code coverage
* Support for: Postgres, H2, Liquibase, TestContainers
* Generates a docker-compose.yaml file to launch the micro-service and database
* Support for SonarQube to enable code coverage analysis
* Generates a README file with instructions on how to build and maintain the generated code

## Installation

A Homebrew Tap exists for this code.  To install with homebrew, do this:

```[bash]
   $ brew tap staycaffeinated/tap
   $ brew install metacode
```
To verify the success of the installation, run:

```[bash]
   $ metacode --version
```

## Basic Command Syntax:

MetaCode supports POSIX-style syntax, allowing options to be specified as
```--option VALUE```, or ```-o VALUE```, or ```-o=VALUE``` and other
variations.

Help is available with the _help_ option, ```-h``` or ```--help```.
For example,

```[bash]
    $ metacode create project --help
```

shows the different options for creating a project.

When creating a project, MetaCode follows the convention

```[bash]
    $ metacode create project [FRAMEWORK] ...
```

When a project is created, a _metacode.properties_ file is written in
the project's base directory.  The values in this file are used when
endpoints are added to the project.

The simplest way to create a project is to declare the framework,
then specify the application name, base package, and base path, such as:

```[bash]
    $ metacode create project spring-webmvc --name petstore --package org.acme.petstore --base-path /petstore
```

which creates the project assets in the current directory,
with the default Java package name of ```org.acme.petstore``` and
a base URL of ```http://localhost:8080/petstore```

A base project will have a root controller that returns an HTTP 200 without a response body.
To add additional endpoints, use the ```create endpoint``` command:
For example,

```[bash]
    $ metacode create endpoint --resource Pet --route /pet
    $ metacode create endpoint --resource Store --route /store
```

## A 15-Minute Tutorial

> Before starting, it is important to know MetaCode creates the source code and other artifacts
> in your _current working directory_, so be sure to navigate to the folder in which
> you want the project assets created _before_ running any command.

Let's walk through two examples, using Spring's venerable Pet Store example
as the starting point.  We'll implement two resources, Pet and Store.

### Building the Pet Store as a Spring WebMvc Application

Step 1: Create a new directory; we'll start with a Spring WebMvc project:

```[bash]
   $ mkdir petstore-webmvc
   $ cd petstore-webmvc
```

Step 2: Create the project-level assets:

```[bash]
   $ metacode create project spring-webmvc --name petstore --package org.acme.petstore --base-path /petstore
```

Step 3: Create the Gradle wrapper

```[bash]
   $ gradle wrapper
```

Step 4: Compile the code

```[bash]
   $ ./gradlew build
```

Step 5: Add an endpoint for Pets

```[bash]
   $ metacode create endpoint --resource Pet --route /pet
```

Step 6: Add an endpoint for Stores

```[bash]
   $ metacode create endpoint --resource Store --route /store
```

Step 7: Compile the new code

```[bash]
   $ ./gradlew build
```

Step 8: Run the application

```[bash]
   $ ./gradlew bootRun
```

Step 9: Try it out in a browser

Try these URLs to see how the generated code behaves:

```[http request]
http://localhost:8080/petstore
http://localhost:8080/petstore/pet/
http://localhost:8080/petstore/pet/findAll
http://localhost:8080/petstore/store/
http://localhost:8080/petstore/store/findAll
```

The generated entities only have two instance variables, _resourceId_
and _text_. The _resourceId_ is separate from the database identifier
to reinforce the practice of not exposing database identifiers to
the outside world.

The structure of the generated entities is intentionally kept simple.
MetaCode does not (yet) read Swagger documents, so the generator
endeavors to create a minimum, viable starting point for your new application.


### Building the Pet Store as a Spring WebFlux Application

Step 1: Create a new directory for the project:

```[bash]
   $ mkdir petstore-webflux
   $ cd petstore-webflux
```

Step 2: Create the project-level assets:

```[bash]
   $ metacode create project spring-webflux --name petstore --package org.acme.petstore --base-path /petstore
```

Step 3: Create the Gradle wrapper

```[bash]
   $ gradle wrapper
```

Step 4: Compile the code

```[bash]
   $ ./gradlew build
```

Step 5: Add an endpoint for Pets

```[bash]
   $ metacode create endpoint --resource Pet --route /pet
```

Step 6: Add an endpoint for Store

```[bash]
   $ metacode create endpoint --resource Store --route /store
```

Step 7: Compile the new code

```[bash]
   $ ./gradlew build
```

Step 8: Run the application

```[bash]
   $ ./gradlew bootRun
```

Step 9: Try it out in a browser

Try these URLs to see how the generated code behaves:

```[http request]
http://localhost:8080/petstore
http://localhost:8080/petstore/pet/
http://localhost:8080/petstore/pet/findAll
http://localhost:8080/petstore/store/
http://localhost:8080/petstore/store/findAll
```

## Additional Steps

### Build a Docker image for the application

The Gradle build uses JIB as the tool to build
the Docker image.  JIB allows the base image
to be specified, which enables the developer to
specify a hardened base image instead of an
off-the-shelf image.

To build the Docker image, run:

```[bash]
   $ ./gradlew jibBuildTar
```

### Check the health of the running application

To check the health of the microservice, the following URL works
with both Spring WebMvc and Spring WebFlux projects.

```[http request]
   http://localhost:8080/petstore/_internal/health
```

This endpoint is actually Spring's Actuator endpoint,
with the path declared in the ```application.properties```.
It can be modified to whatever is preferred.


### Export to SonarQube

The build scripts use Jacoco and Sonarqube
to generate code coverage reports. Of course,
to use Sonarqube, you have to have Sonarqube
running.  A local instance of Sonarqube can be
started via Docker. Bitnami offers a _docker-compose_ file
for running Sonarqube locally; the instructions are found
here:

```[http request]
https://hub.docker.com/r/bitnami/sonarqube
```
The credentials to that instance of Sonarqube
are contained in the docker-compose.yml file.
The credentials do get rotated by Bitnami, so
expect them to change at least every month.

With Sonarqube running, continue with these steps.
In the project's root directory, edit the
_gradle.properties_ file and update the
Sonarqube credentials. You may also want to
change the _systemProp.sonar.projectKey_, but that's
optional.

With the _gradle.properties_ updated and saved, run:

```[bash]
   $ ./gradlew build integrationTest jacocoTestReport sonarqube
```

When these Gradle tasks finish, login to the Sonarqube
console to see the results (e.g., http://localhost:80,
or whatever port is specified in Bitnami's docker-compose.yml file).

### Adding Integration to Postgres, TestContainers, and Liquibase

MetaCode supports adding dependencies to a project.
The generated code accounts for these dependencies.
For example, if Postgres is used, the generated
_application.properties_ will have Postgres JDBC properties
and the _build.gradle_ will include the Postgres JDBC driver.
If TestContainers are used, a TestContainer applicable to
the selected database is generated.  If Liquibase is
added, the _liquibase_ properties are added to the
_application.properties_ and a _db.changelog-master.yaml_ file
and _db.changelog-001-create-schema.yaml_ file are
created.

These integrations have to be specified when the project is
created, since their usage affects how the code is
generated.  To add these integrations, so something like:

```[bash]
   $ metacode create project spring-webflux --name petstore --package org.acme.petstore --base-path /petstore --support postgres testcontainers liquibase
```

Naturally, you can cherry-pick the integrations to add; for instance,
integrating only Postgres and TestContainers is supported.

# References

1. <a href="https://www.2uo.de/myths-about-urandom/">Myths About /dev/urandom</a>
2. <a href="https://resources.infosecinstitute.com/topic/random-number-generation-java/">Secure Random Number Generation in Java</a> (14 Dec 2011)
3. <a href="https://neilmadden.blog/2018/08/30/moving-away-from-uuids/">Moving Away from UUIDs</a> (30 Aug 2018)
4. <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-10.10">The OAuth2 Authorization Framework: Credentials-Guessing Attacks</a> (Oct 2012)
